<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Nil RTOS: Kernel Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nil RTOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Nil RTOS</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Kernel Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Nil RTOS Kernel Concepts</p>
<ul>
<li><a class="el" href="concepts.html#naming">Naming Conventions</a></li>
<li><a class="el" href="concepts.html#api_suffixes">API Name Suffixes</a></li>
<li><a class="el" href="concepts.html#interrupt_classes">Interrupt Classes</a></li>
<li><a class="el" href="concepts.html#system_states">System States</a></li>
<li><a class="el" href="concepts.html#scheduling">Scheduling</a></li>
<li><a class="el" href="concepts.html#thread_states">Thread States</a></li>
<li><a class="el" href="concepts.html#priority">Priority Levels</a></li>
<li><a class="el" href="concepts.html#warea">Thread Working Area</a></li>
</ul>
<h1>Ignore the Rest of this Page</h1>
<p>This page has not been edited for Nil RTOS.</p>
<h1><a class="anchor" id="naming"></a>
Naming Conventions</h1>
<p>Nil RTOS APIs are all named following this convention: <em>nil&lt;group&gt;&lt;action&gt;&lt;suffix&gt;</em>(). The possible groups are: <em>Sys</em>, <em>Thd</em>, <em>Sem</em>.</p>
<h1><a class="anchor" id="api_suffixes"></a>
API Name Suffixes</h1>
<p>The suffix can be one of the following:</p>
<ul>
<li><b>None</b>, APIs without any suffix can be invoked only from the user code in the <b>Normal</b> state unless differently specified. See <a class="el" href="concepts.html#system_states">System States</a>.</li>
<li><a class="anchor" id="I-Class"></a><b>"I"</b>, I-Class APIs are invokable only from the <b>I-Locked</b> or <b>S-Locked</b> states. See <a class="el" href="concepts.html#system_states">System States</a>.</li>
<li><a class="anchor" id="S-Class"></a><b>"S"</b>, S-Class APIs are invokable only from the <b>S-Locked</b> state. See <a class="el" href="concepts.html#system_states">System States</a>.</li>
</ul>
<p>Examples: <code><a class="el" href="group__nil.html#gac59b7eeedf0fb1e13863755e79181544" title="Suspends the invoking thread for the specified time. ">nilThdSleep()</a></code>, <code><a class="el" href="group__nil.html#ga45023f8308114e6500ad282617116ec2" title="Performs a signal operation on a semaphore. ">nilSemSignalI()</a></code>, <code><a class="el" href="group__nil.html#gaa4453e9daa0033e31789b720208db96b" title="System halt state. ">nilSysHalt()</a></code>.</p>
<h1><a class="anchor" id="interrupt_classes"></a>
Interrupt Classes</h1>
<p>In ChibiOS/RT there are three logical interrupt classes:</p>
<ul>
<li><b>Regular Interrupts</b>. Maskable interrupt sources that cannot preempt (small parts of) the kernel code and are thus able to invoke operating system APIs from within their handlers. The interrupt handlers belonging to this class must be written following some rules. See the web article <a href="http://chibios.sourceforge.net/dokuwiki/doku.php?id=chibios:howtos:interrupts">How to write interrupt handlers</a>.</li>
<li><b>Fast Interrupts</b>. Maskable interrupt sources with the ability to preempt the kernel code and thus have a lower latency and are less subject to jitter, see the web article <a href="http://chibios.sourceforge.net/dokuwiki/doku.php?id=chibios:articles:jitter">Response Time and Jitter</a>. Such sources are not supported on all the architectures.<br/>
 Fast interrupts are not allowed to invoke any operating system API from within their handlers. Fast interrupt sources may, however, pend a lower priority regular interrupt where access to the operating system is possible.</li>
<li><b>Non Maskable Interrupts</b>. Non maskable interrupt sources are totally out of the operating system control and have the lowest latency. Such sources are not supported on all the architectures.</li>
</ul>
<p>The mapping of the above logical classes into physical interrupts priorities is, of course, port dependent. See the documentation of the various ports for details.</p>
<h1><a class="anchor" id="system_states"></a>
System States</h1>
<p>When using ChibiOS/RT the system can be in one of the following logical operating states:</p>
<ul>
<li><b>Init</b>. When the system is in this state all the maskable interrupt sources are disabled. In this state it is not possible to use any system API except <code>chSysInit()</code>. This state is entered after a physical reset.</li>
<li><b>Normal</b>. All the interrupt sources are enabled and the system APIs are accessible, threads are running.</li>
<li><b>Suspended</b>. In this state the fast interrupt sources are enabled but the regular interrupt sources are not. In this state it is not possible to use any system API except <code>chSysDisable()</code> or <code>chSysEnable()</code> in order to change state.</li>
<li><b>Disabled</b>. When the system is in this state both the maskable regular and fast interrupt sources are disabled. In this state it is not possible to use any system API except <code>chSysSuspend()</code> or <code>chSysEnable()</code> in order to change state.</li>
<li><b>Sleep</b>. Architecture-dependent low power mode, the idle thread goes in this state and waits for interrupts, after servicing the interrupt the Normal state is restored and the scheduler has a chance to reschedule.</li>
<li><b>S-Locked</b>. Kernel locked and regular interrupt sources disabled. Fast interrupt sources are enabled. <a class="el" href="concepts.html#S-Class">S-Class</a> and <a class="el" href="concepts.html#I-Class">I-Class</a> APIs are invokable in this state.</li>
<li><b>I-Locked</b>. Kernel locked and regular interrupt sources disabled. <a class="el" href="concepts.html#I-Class">I-Class</a> APIs are invokable from this state.</li>
<li><b>Serving Regular Interrupt</b>. No system APIs are accessible but it is possible to switch to the I-Locked state using <code>chSysLockFromIsr()</code> and then invoke any <a class="el" href="concepts.html#I-Class">I-Class</a> API. Interrupt handlers can be preemptable on some architectures thus is important to switch to I-Locked state before invoking system APIs.</li>
<li><b>Serving Fast Interrupt</b>. System APIs are not accessible.</li>
<li><b>Serving Non-Maskable Interrupt</b>. System APIs are not accessible.</li>
<li><b>Halted</b>. All interrupt sources are disabled and system stopped into an infinite loop. This state can be reached if the debug mode is activated <b>and</b> an error is detected <b>or</b> after explicitly invoking <code>chSysHalt()</code>.</li>
</ul>
<p>Note that the above states are just <b>Logical States</b> that may have no real associated machine state on some architectures. The following diagram shows the possible transitions between the states:</p>
<h1><a class="anchor" id="scheduling"></a>
Scheduling</h1>
<p>The strategy is very simple the currently ready thread with the highest priority is executed.</p>
<p>A thread's priority is determined by its position in the thread table with higest priority first.</p>
<h1><a class="anchor" id="thread_states"></a>
Thread States</h1>
<h1><a class="anchor" id="priority"></a>
Priority Levels</h1>
<h1><a class="anchor" id="warea"></a>
Thread Working Area</h1>
<p>Each thread has its own stack, a Thread structure and some preemption areas. All the structures are allocated into a "Thread Working Area", a thread private heap, statically declared in your code. Threads do not use any memory outside the allocated working area except when accessing static shared data.<br/>
<br/>
</p>
<p>Note that the preemption area is only present when the thread is not running (switched out), the context switching is done by pushing the registers on the stack of the switched-out thread and popping the registers of the switched-in thread from its stack. The preemption area can be divided in up to three structures:</p>
<ul>
<li>External Context.</li>
<li>Interrupt Stack.</li>
<li>Internal Context.</li>
</ul>
<p>See the port documentation for details, the area may change on the various ports and some structures may not be present (or be zero-sized). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 16 2014 11:31:29 for Nil RTOS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
